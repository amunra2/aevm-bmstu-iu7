\chapter{Теоритические основы}
При выполнении лабораторной работы будет использоваться ускоритель вычислений на \textbf{Xilinx Alveo}.

\section{Методология ускорения вычислений на основе ПЛИС}

Ускорение вычислительных алгоритмов с использованием программируемых логических интегральных схем (ПЛИС) имеет ряд преимуществ по сравнению с их реализацией на универсальных микропроцессорах, или графических процессорах. В то время, как традиционная разработка программного обеспечения связана с программированием на заранее определенном наборе машинных команд, разработка программируемых устройств - это создание специализированной вычислительной структуры для реализации желаемой функциональности.


Микропроцессоры и графические процессоры имеют предопределенную архитектуру с фиксированным количеством ядер, набором инструкций, и жесткой архитектурой памяти, и обладают высокими тактовыми частотами и хорошо сбалансированной конвейерной структурой. Графические процессоры масштабируют производительность за счет большого количества ядер и использования параллелизма SIMD/SIMT (Рисунок \ref{img:dif_plats}). В отличие от них, программируемые устройства представляют собой полностью настраиваемую архитектуру, которую разработчик может использовать для размещения вычислительных блоков с требуемой функциональностью. В таком случает, высокий уровень производительности достигается за счет создания длинных конвейеров обработки данных, а не за счет увеличения количества вычислительных единиц. Понимание этих преимуществ является необходимым условием для разработки вычислительных устройств и достижения наилучшего уровня ускорения.

\imgScale{0.2}{dif_plats}{Принципы организации вычислений на различных платформах}

\clearpage

Методологию создания ускорителей на ПЛИС с применением средств синтеза высокого уровня (High Level Synthesis, HLS) можно представить в виде трех этапов:

\begin{itemize}
	\item создание архитектуры приложения;
	\item разработка ядра аппаратного ускорителя на языках C/C++;
	\item анализ производительности и выявление способов ее повышения.
\end{itemize}


\section{Оптимизация времени обработки и пропускной способности}

Существует несколько подходов к оптимизации.

\subsection{Конвейерная обработка циклов}

Полагая, что одна итерация цикла занимает более одного такта (фаза выборки данных, фаза вычисления, фаза записи результата) в таком варианте может быть организован конвейер выполнения. Для этого необходимо поместить в тело цикла прагму <HLS PIPELINE>

Без конвейерной обработки каждая последующая итерация цикла начинается в каждом третьем такте. При конвейерной обработке цикл может начинать последующие итерации цикла менее чем за три такта, например, в каждом втором такте или в каждом такте. Для указания конкретного значения интервала запуска заданий используется свойство Initiation inteval (II). Например: \textbf{\#pragma HLS PIPELINE II = 1}

Стоит отметить, что конвейерная обработка цикла приводит к разворачиванию любых циклов, вложенных внутрь конвейерного цикла. Если внутри цикла существуют зависимости по данным, может оказаться невозможным достичь запуска новой итерации в каждом такте, и результатом может быть больший интервал инициации.


\subsection{Разворачивание циклов}

Разворачивание циклов является общепризнанным механизмом снижения времени выполнения циклов. Этот механизм может быть описан самим разработчиком вручную, если он просто повторит вычисления и сократит количество итераций цикла. С помощью прагмы <HLS UNROLL> компилятор v++ позволяет запустить механизм автоматического разворачивания цикла, частично или полностью.


\subsection{Потоковая обработка}

Реализация механизма потоковой обработки (\#pragma HLS DATAFLOW) также опирается на представление вычислительных действий в виде многостадийного конвейера. Однако, в то время как директива конвейеризации (\#pragma HLS PIPELINE) используется для реализации конвейера выполнения операций внутри функций или циклов, потоковая обработка данных позволяет сформировать конвейер из более крупных вычислительных блоков: нескольких функций или нескольких последовательных циклических конструкций. Таким образом, директива HLS DATAFLOW позволяет сформировать вычислительный конвейер на уровне задач. Для этих целей компилятор HLS Vitis выполнит анализ зависимостей по данным между задачами и реализует структуру обрабатывающих блоков и FIFO очередей между ними.



\chapter{Выполнение лабораторной работы}

Для изучения технологии будут выполнены следующие задания.

\section{Функции ядра по индивидуальному варианту}

В листинге \ref{lst:var19_nopragma} представлен листинг программы без оптимизаций. Также в листинге \ref{lst:var19_nopragma} представлена конвейрная оптимизация прогаммы, а в листинге \ref{lst:var19_unrolled} находится оптимизация частично развернутым циклом. В листиге \ref{lst:var19_unroll} -- конвейрная реализация с частично развернутым циклом.


\begin{center}
    \captionsetup{justification=raggedright,singlelinecheck=off}
    \begin{lstlisting}[label=lst:var19_nopragma,caption=Код программы (без изменений)]
	extern "C" {
		void var019(int* c, const int* a, const int* b, const int len) 
		{
			int tmpA;
			int tmpB;
			int tmpC;

			for(int i = 0; i < len; i++)
			{
				tmpA = a[i];
				tmpB = b[i];

				for (int j = 0; j < 8; j++)
				{
					tmpA = a[i] & 0x7;
					tmpB = b[i] & 0x7;
					tmpC = (tmpA + tmpB) & 0x7;
					
					tmpA = tmpA>>4;
					tmpB = tmpB>>4;
					tmpC = tmpA<<4;
				}

				c[i] = tmpC;
			}
		}
	}
\end{lstlisting}
\end{center}


\begin{center}
    \captionsetup{justification=raggedright,singlelinecheck=off}
    \begin{lstlisting}[label=lst:var19_pipelined,caption=Код программы (конверная)]
	extern "C" {
		void var019_pipelined(int* c, const int* a, const int* b, const int len) 
		{
			#pragma HLS PIPELINE
	
			int tmpA;
			int tmpB;
			int tmpC;
	
			for(int i = 0; i < len; i++)
			{
				tmpA = a[i];
				tmpB = b[i];
	
				for (int j = 0; j < 8; j++)
				{
					tmpA = a[i] & 0x7;
					tmpB = b[i] & 0x7;
					tmpC = (tmpA + tmpB) & 0x7;
					
					tmpA = tmpA>>4;
					tmpB = tmpB>>4;
					tmpC = tmpA<<4;
				}
	
				c[i] = tmpC;
			}
		}
	}		
\end{lstlisting}
\end{center}


\begin{center}
    \captionsetup{justification=raggedright,singlelinecheck=off}
    \begin{lstlisting}[label=lst:var19_unrolled,caption=Код программы (частично развернутый цикл)]
	extern "C" {
		void var019_unrolled(int* c, const int* a, const int* b, const int len) 
		{
			#pragma HLS UNROLL
	
			int tmpA;
			int tmpB;
			int tmpC;
	
			for(int i = 0; i < len; i++)
			{
				tmpA = a[i];
				tmpB = b[i];
	
				for (int j = 0; j < 8; j++)
				{
					tmpA = a[i] & 0x7;
					tmpB = b[i] & 0x7;
					tmpC = (tmpA + tmpB) & 0x7;
					
					tmpA = tmpA>>4;
					tmpB = tmpB>>4;
					tmpC = tmpA<<4;
				}
	
				c[i] = tmpC;
			}
		}
	}
\end{lstlisting}
\end{center}


\begin{center}
    \captionsetup{justification=raggedright,singlelinecheck=off}
    \begin{lstlisting}[label=lst:var19_unroll,caption=Код программы (конвейрный с частично развернутым циклом)]
	extern "C" {
		void var019_pipe_unroll(int* c, const int* a, const int* b, const int len) 
		{
			#pragma HLS DATAFLOW
	
			int tmpA;
			int tmpB;
			int tmpC;
	
			for(int i = 0; i < len; i++)
			{
				tmpA = a[i];
				tmpB = b[i];
	
				for (int j = 0; j < 8; j++)
				{
					tmpA = a[i] & 0x7;
					tmpB = b[i] & 0x7;
					tmpC = (tmpA + tmpB) & 0x7;
					
					tmpA = tmpA>>4;
					tmpB = tmpB>>4;
					tmpC = tmpA<<4;
				}
	
				c[i] = tmpC;
			}
		}
	}
\end{lstlisting}
\end{center}

\clearpage


\section{Режим Emulation-SW}

На рисунке \ref{img:emu_sw} представлен результат работы в режиме \textbf{Emulation-SW}.


\imgScale{0.3}{emu_sw}{Результаты работы приложения в режиме Emulation-SW}


\section{Режим Emulation-HW}

На рисунке \ref{img:a_view_emu_hw} представлена копия экрана \textbf{Assistant View} для \textbf{Emulation-HW}, а на рисунке \ref{img:emu_hw} представлен результат работы приложения в режиме \textbf{Emulation-HW}. А также на рисунке \ref{img:vivado_emu_hw} представлена схема отладчика \textbf{Vivado}.

\imgScale{0.3}{a_view_emu_hw}{Assistant View для Emulation-HW}
\imgScale{0.3}{emu_hw}{Результаты работы приложения в режиме Emulation-HW}
\imgScale{0.3}{vivado_emu_hw}{Схема отладчика Vivado для Emulation-HW}


\section{Режим HardWare}

На рисунке \ref{img:hw} представлен результат работы в режиме \textbf{HardWare}. Также на рисунке \ref{img:hw_summary} представлен снимок экрана вкладки \textbf{Summary}, на рисунке \ref{img:hw_sysdiag} -- вкладки \textbf{System Diagram}, на рисунке \ref{img:hw_platformdiag} -- вкладки \textbf{Platform Diagram}. При этом на рисунках \ref{img:hw_hls1}--\ref{img:hw_hls2} представлены снимки экрана \textbf{HLS Synthesis} для каждой из функций.

\clearpage

\imgScale{0.3}{hw}{Результаты работы приложения в режиме HardWare}

\imgScale{0.3}{hw_summary}{Вкладка Summary}
\imgScale{0.3}{hw_sysdiag}{Вкладка System Diagram}
\imgScale{0.3}{hw_platformdiag}{Вкладка Platform Diagram}

\imgScale{0.3}{hw_hls1}{Вкладка HLS Synthesis для var019\_no\_pragmas}
\imgScale{0.3}{hw_hls2}{Вкладка HLS Synthesis для var019\_pipe\_unroll}
\imgScale{0.3}{hw_hls3}{Вкладка HLS Synthesis для var019\_pipelined}
\imgScale{0.3}{hw_hls4}{Вкладка HLS Synthesis для var019\_unrolled}

\clearpage


\section{Обоснование результатов и выводы}

Как видно из результов, наибольшее время выполнения у цикла без оптимизаций. При этом наименьшее время было достигнуто при развернутом цикле. Это связано с тем, что все развернутые итерации выполняются параллельно, при этом уменьшается количество итераций.



