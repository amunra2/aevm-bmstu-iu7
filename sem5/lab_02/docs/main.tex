\chapter{Теоритические основы}
При исследовании производительности будет использована архитектура набора команд \textbf{RV32I}. 

\section{Архитектура набора команд RV32I}

\textbf{RISC-V} является открытым современным набором команд, который может использоваться для построения как микроконтроллеров, так и высокопроизводительных микропроцессоров. В связи с такой широкой областью применения в систему команд введена вариативность. Таким образом, термин RISC-V фактически является названием для семейства различных систем команд, которые строятся вокруг базового набора команд, путем внесения в него различных расширений.

В данной работе исследуется набор команд \textbf{RV32I}, который включает в себя основные
команды 32-битной целочисленной арифметики кроме умножения и деления. В рамках
данного набора команд мы не будем рассматривать системные команды, связанные с
таймерами, системными регистрами, управлением привилегиями, прерываниями и исключениями.


\chapter{Выполнение лабораторной работы}

Для знакомства с RISC-V будут выполнены необходимые задачи.

\section{Задание 1}

Дизассемблирование индивидуальной программы.

\subsection{Результат выполнения задания}

На рисунке \ref{img:var19_prog} представлен код программы для индивидуального задания по 19 варианту. При этом на рисунке \ref{img:var19_asm}, а в листинге \ref{lst:var19_c} код на языке Си для данной программы. 

\imgScale{0.5}{var19_prog}{Код программы}
\imgScale{0.5}{var19_asm}{Код программы (дизассемблированный)}

\clearpage

\begin{center}
    \captionsetup{justification=raggedright,singlelinecheck=off}
    \begin{lstlisting}[label=lst:var19_c,caption=Код программы (на языке Си)]
#define LEN 9
#define ENROLL 2
#define ELEM_SZ 4

int _x[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};

int main(void)
{
	int *x1 = _x;
	int x20 = (LEN - 1) / ENROLL;
	int x31 = x1[0];

	x1 += ELEM_SZ;

	do
	{
		int x2 = x1[0];
		int x3 = x1[1];

		if (!(x3 < x31))
		{
			x31 = x2;
		}

		if (!(x3 < x31))
		{
			x31 = x3;
		}

		x1 += ELEM_SZ * ENROLL;
		x20 -= 1;
	} while (x20 != 0);

	while(1) {}

	return 0;
}
\end{lstlisting}
\end{center}


\subsection{Вывод}

В программе, которая представлена на рисунке \ref{img:var19_prog}, находится максимум из элементов массива. В результате, в \textbf{x31} будет находиться максимальное число из массива \textbf{\_x}, причем, в \textbf{x31} будет помещен последний из максимумов, если их было встречено несколько одинакомых. Тогда в результате выполнения программы в \textbf{x31} будет лежать 0x9.


\section{Задание 2}

\textbf{Задание:} Получить снимок экрана, содержащий временную диаграмму выполнения стадий \textit{выборки и диспетчеризации} команды со следующим адресом: 80000028, 2-ая итерация.

\subsection{Результат выполнения задания}

Сигнал \textbf{fetch\_complete} = 1 -- диспетчеризация произошла предыдущем такте.
На рисунках \ref{img:task21}--\ref{img:task22} представлены временные диаграммы этапов выборки и диспетчеризации.


\imgScale{0.3}{task21}{Диаграмма этапа выборки}
\imgScale{0.3}{task22}{Диаграмма этапа диспетчеризации}

\clearpage


\subsection{Вывод}

Поскольку выборка и диспетчеризация предыдущих команд уже произошли, то выборка и диспетчеризация вышеуказанной команды произошли последовательно, то есть без задержки по тактам.


\section{Задание 3}

\textbf{Задание:} Получить снимок экрана, содержащий временную диаграмму выполнения стадий \textit{декодирования и планирования} команды со следующим адресом: 80000034, 2-ая итерация.

\subsection{Результат выполнения задания}

На рисунках \ref{img:task31}--\ref{img:task32} представлены временные диаграммы этапов декодирования и планирования. Как видно, в конце 47-го такта виден результат декодирования, а 48-ой такт -- планирование на выполнение.


\imgScale{0.3}{task31}{Диаграмма этапа декодирования}
\imgScale{0.3}{task32}{Диаграмма этапа планирования}

\clearpage


\subsection{Вывод}

Поскольку декодирование и планирование предыдущих команд уже произошли, то декодирования и планирования вышеуказанной команды произошли последовательно, то есть без задержки по тактам.


\section{Задание 4}

\textbf{Задание:} Получить снимок экрана, содержащий временную диаграмму стадии \textit{выполнения} команды со следующим адресом: 80000020, 2-ая итерация.

\subsection{Результат выполнения задания}

На рисунке \ref{img:task4} представлена временная диаграмма этапа выполнения. Выполнение команды происходит, когда сигналы \textit{unit\_issue[0] / new\_request = 1} и \textit{unit\_wb[0] / done = 1}.

\imgScale{0.3}{task4}{Диаграмма этапа выполнения}

\clearpage


\subsection{Вывод} 

Выполнение произошло не на следующем же такте после стадии декодирования (41 и 38), так как возникли конфликты, вызванные тем, что регистр был занят выполнением другой команды.



\section{Задание 5}

Выполнить необходимые задания.

\subsection{Часть 1}

\textbf{Задание:} Сравнить значение регистра x31 (сигнал /tb/register\_file[31]) на момент окончания выполнения программы с тем, который был получен в задании 1.

На рисунке \ref{img:task51} представлен результат выполнения программы. Как видно, значение равно 0x9, что соответствует результату, полученному в задании 1.

\imgScale{0.4}{task51}{Результат выполнения программы}

\clearpage


\subsection{Часть 2}

\textbf{Задание:} Получить снимок экрана, содержащий временные диаграммы сигналов, соответствующих всем стадиям выполнения команды, обозначеннной в тексте программы символом \#!

\textit{Для программы из Варианта 19}: add x31, x0, x2 \#!

На рисунках \ref{img:task521}-\ref{img:task524} представлены этапы выполнения команды.

\imgScale{0.35}{task521}{Выборка команды с символом \#!}
\imgScale{0.35}{task522}{Диспетчеризация команды с символом \#!}
\imgScale{0.35}{task523}{Декодирование команды с символом \#!}
\imgScale{0.35}{task524}{Выполнение команды с символом \#!}

\clearpage


\subsection{Часть 3}

\textbf{Задание:} Анализируя диаграмму, заполнить трассу выполнения программы.

На рисунке \ref{img:task53} представлена трасса программы.

\imgScale{0.4}{task53}{Трасса программы}

\clearpage



\subsection{Часть 4}

\textbf{Задание:} Оптимизировать программу с целью устранения конфликтов.

Как видно из трассы для неоптимизированной программы на рисунке \ref{img:task53}, во время работы программы произошло 4 конфликта, которые связаны с командой bltu x2, x31, lt1. 

В качестве оптимизации переставим некоторые команды местами. Оптимизированный код представлен на рисунке \ref{img:task541}, на рисунке \ref{img:task542} -- дизассемблированный код оптимизированной программы, а на рисунке \ref{img:task543} -- трасса оптимизированной программы. Как видно, удалось сократить количество конфликтов до 1.

\imgScale{0.4}{task541}{Оптимизированный код программы}
\imgScale{0.4}{task542}{Дизассемблированный код оптимизированной программы}
\imgScale{0.4}{task543}{Трасса оптимизированной программы}

\clearpage


\textbf{Вывод:} оптимизация программ позволяет устранить конфликты. В данной ситуации удалось устранить 3 конфликта из 4, переставив местами некоторые команды. Это говорит о том, что правильное расположение команд имеет большое значение при работе с программами.